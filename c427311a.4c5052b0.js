(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{134:function(e,a,t){"use strict";t.r(a),t.d(a,"frontMatter",(function(){return l})),t.d(a,"metadata",(function(){return o})),t.d(a,"rightToc",(function(){return s})),t.d(a,"default",(function(){return c}));var n=t(2),i=t(6),r=(t(0),t(163)),l={title:"Type basics"},o={unversionedId:"api/start/types.basics",id:"api/start/types.basics",isDocsHomePage:!1,title:"Type basics",description:"We've touched upon types in most previous sections, i.e. that these are driven by metadata and that they are created and converted to/from automatically by the API. Since they appear in all results, we will divert a bit from the regularly scheduled program in explaining the API interfaces to giving some info on the base types.",source:"@site/docs/api/start/types.basics.md",slug:"/api/start/types.basics",permalink:"/docs/api/start/types.basics",editUrl:"https://github.com/polkadot-js/docs/edit/master/docs/api/start/types.basics.md",version:"current",sidebar:"reference",previous:{title:"Complex transactions",permalink:"/docs/api/start/api.tx.wrap"},next:{title:"Extending types",permalink:"/docs/api/start/types.extend"}},s=[{value:"Everything is a type",id:"everything-is-a-type",children:[]},{value:"Comparing types",id:"comparing-types",children:[]},{value:"Working with numbers",id:"working-with-numbers",children:[]},{value:"Working with structures",id:"working-with-structures",children:[]},{value:"Working with enums",id:"working-with-enums",children:[]},{value:"Working with Option&lt;Type&gt;",id:"working-with-optiontype",children:[]},{value:"Working with Tuples",id:"working-with-tuples",children:[]},{value:"Boolean values",id:"boolean-values",children:[]},{value:"Extending types",id:"extending-types",children:[]}],p={rightToc:s};function c(e){var a=e.components,t=Object(i.a)(e,["components"]);return Object(r.a)("wrapper",Object(n.a)({},p,t,{components:a,mdxType:"MDXLayout"}),Object(r.a)("p",null,"We've touched upon types in most previous sections, i.e. that these are driven by metadata and that they are created and converted to/from automatically by the API. Since they appear in all results, we will divert a bit from the regularly scheduled program in explaining the API interfaces to giving some info on the base types."),Object(r.a)("h2",{id:"everything-is-a-type"},"Everything is a type"),Object(r.a)("p",null,"Just to re-iterate from the above. Everything returned by the API is a type and has a consistent interface. This means that a ",Object(r.a)("inlineCode",{parentName:"p"},"Vec<u32>")," (an array of ",Object(r.a)("inlineCode",{parentName:"p"},"u32")," values) as well as a ",Object(r.a)("inlineCode",{parentName:"p"},"Struct")," (an pre-defined object) or an ",Object(r.a)("inlineCode",{parentName:"p"},"Enum")," has the same consistent base interface. Specific types types will have values, based on the type - decorated and available."),Object(r.a)("p",null,"As a minimum, anything returned by the API, be it a ",Object(r.a)("inlineCode",{parentName:"p"},"Vec<...>"),", ",Object(r.a)("inlineCode",{parentName:"p"},"Option<...>"),", ",Object(r.a)("inlineCode",{parentName:"p"},"Struct")," or any normal type will always have the following methods -"),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},".eq(<other value>)"),' - checks for equality against the other value. In all cases, it will accept "like" values, i.e. in the case of a number you can pass a primitive (such as ',Object(r.a)("inlineCode",{parentName:"li"},"1"),"), a hex value (such as ",Object(r.a)("inlineCode",{parentName:"li"},"0x01"),") or even an ",Object(r.a)("inlineCode",{parentName:"li"},"Unit8Array")),Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},"toHex()")," - returns a hex-base representation of the value, always prefixed by ",Object(r.a)("inlineCode",{parentName:"li"},"0x")),Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},"toHuman()")," - returns Human-parsable JSON structure with values formatted as per the settings"),Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},"toJSON()")," - returns a JSON-like representation of the value, this is generally used when calling ",Object(r.a)("inlineCode",{parentName:"li"},"JSON.stringify(...)")," on the value"),Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},"toString()")," - returns a string representation, in some cases this performs additional encoding, i.e. for ",Object(r.a)("inlineCode",{parentName:"li"},"Address"),", ",Object(r.a)("inlineCode",{parentName:"li"},"AccountId")," and ",Object(r.a)("inlineCode",{parentName:"li"},"AccountIndex")," it will encode to the ss58 address"),Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},".toU8a()")," - returns a ",Object(r.a)("inlineCode",{parentName:"li"},"Uint8Array")," representation of the encoded value (generally exactly as passed to the node, where values are SCALE encoded)")),Object(r.a)("p",null,"Additionally, the following getters and utilities are available -"),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},".isEmpty")," - ",Object(r.a)("inlineCode",{parentName:"li"},"true")," if the value is an all-empty value, i.e. ",Object(r.a)("inlineCode",{parentName:"li"},"0")," in for numbers, all-zero for Arrays (or anything ",Object(r.a)("inlineCode",{parentName:"li"},"Uint8Array"),"), ",Object(r.a)("inlineCode",{parentName:"li"},"false")," is non-zero"),Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},".hash")," - a ",Object(r.a)("inlineCode",{parentName:"li"},"Hash")," (once again with all the methods above) that is a ",Object(r.a)("inlineCode",{parentName:"li"},"blake2-256")," representation of the contained value")),Object(r.a)("h2",{id:"comparing-types"},"Comparing types"),Object(r.a)("p",null,"To reiterate the above API, the ",Object(r.a)("inlineCode",{parentName:"p"},".eq")," method is the preferred means of comparing base types, rather than the JavaScript equality operator (",Object(r.a)("inlineCode",{parentName:"p"},"==="),")."),Object(r.a)("p",null,"For example:"),Object(r.a)("pre",null,Object(r.a)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const { metadata } = await api.rpc.state.getMetadata();\nconst modules = metadata.asLatest.modules;\n\n// This will not work, because `name` is an instance of `Text`, not a string\n// const system = modules.find(m => m.name === 'system');\n\n// This will work, because `Text.eq()` can compare against a string\nconst system = modules.find(m => m.name.eq('system'));\n")),Object(r.a)("h2",{id:"working-with-numbers"},"Working with numbers"),Object(r.a)("p",null,"All numbers wrap and extend an instance of ",Object(r.a)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/indutny/bn.js/"}),"bn.js"),". This means that in addition to the interfaces defined above, they have some additional methods -"),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},".toNumber()")," - a JS number (limited to 2^53 - 1). This does mean that for large values, e.g. ",Object(r.a)("inlineCode",{parentName:"li"},"Balance")," (a ",Object(r.a)("inlineCode",{parentName:"li"},"u128")," extension), this can cause overflows"),Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},".toBigInt()")," - a JS ",Object(r.a)("inlineCode",{parentName:"li"},"BigInt")," object (on supported platforms)"),Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},".add(...)"),", ",Object(r.a)("inlineCode",{parentName:"li"},".sub(...)"),", ... - all the base methods available on the ",Object(r.a)("inlineCode",{parentName:"li"},"BN")," object")),Object(r.a)("p",null,"In cases where a ",Object(r.a)("inlineCode",{parentName:"p"},"Compact")," is returned, i.e. ",Object(r.a)("inlineCode",{parentName:"p"},"Compact<Balance>"),", the value is wrapped. This object should be ",Object(r.a)("inlineCode",{parentName:"p"},".unwrap()"),"-ed first to gain access to the underlying ",Object(r.a)("inlineCode",{parentName:"p"},"Balance")," object."),Object(r.a)("h2",{id:"working-with-structures"},"Working with structures"),Object(r.a)("p",null,"All structures, a wrapping of an object containing a number of member variables, is an implementation of a standard JS ",Object(r.a)("inlineCode",{parentName:"p"},"Map")," object, so all the functions available on a ",Object(r.a)("inlineCode",{parentName:"p"},"Map")," such as ",Object(r.a)("inlineCode",{parentName:"p"},".entries()")," are available. Additionally it is decorated with actual getters for the fields."),Object(r.a)("p",null,"As an example, a ",Object(r.a)("inlineCode",{parentName:"p"},"Header")," will have getters for the ",Object(r.a)("inlineCode",{parentName:"p"},".parentHash"),", ",Object(r.a)("inlineCode",{parentName:"p"},".number"),", ",Object(r.a)("inlineCode",{parentName:"p"},".stateRoot"),", ",Object(r.a)("inlineCode",{parentName:"p"},".extrinsicsRoot")," and ",Object(r.a)("inlineCode",{parentName:"p"},".digest")," fields. The same applies for all structures, as they are returned, each member will have an associated getter."),Object(r.a)("p",null,"Be aware that in the JS version naming defaults to ",Object(r.a)("inlineCode",{parentName:"p"},"camelCase")," where names of fields in Substrate defaults to ",Object(r.a)("inlineCode",{parentName:"p"},"snake_case"),". (Each version aligning with conventions in the respective languages)"),Object(r.a)("h2",{id:"working-with-enums"},"Working with enums"),Object(r.a)("p",null,"Each enum has additional getters which are injected based on the fields wrapped. These take the form of ",Object(r.a)("inlineCode",{parentName:"p"},".is<Name>")," and ",Object(r.a)("inlineCode",{parentName:"p"},".as<Name>")," to allow you to check is the enum is a certain value or to retrieve the underlying value as a specific type."),Object(r.a)("p",null,"As a real-world example, when an extrinsic is applied, the ",Object(r.a)("inlineCode",{parentName:"p"},"Phase")," enum has one of two states, ",Object(r.a)("inlineCode",{parentName:"p"},"ApplyExtrinsic(u32)")," or ",Object(r.a)("inlineCode",{parentName:"p"},"Finalization"),". In this case ",Object(r.a)("inlineCode",{parentName:"p"},".isApplyExtrinsic")," would be ",Object(r.a)("inlineCode",{parentName:"p"},"true")," when an extrinsic is being applied, and ",Object(r.a)("inlineCode",{parentName:"p"},".asApplyExtrinsic")," would return the value as a ",Object(r.a)("inlineCode",{parentName:"p"},"u32")," (which is the index of the extrinsic in the block, as it is being applied). When ",Object(r.a)("inlineCode",{parentName:"p"},"isApplyExtrinsic")," is ",Object(r.a)("inlineCode",{parentName:"p"},"false")," and ",Object(r.a)("inlineCode",{parentName:"p"},"asApplyExtrinsic")," is called, the getter will throw."),Object(r.a)("h2",{id:"working-with-optiontype"},"Working with Option","<","Type",">"),Object(r.a)("p",null,"An ",Object(r.a)("inlineCode",{parentName:"p"},"Option<Type>")," attempts to mimic the Rust approach of having ",Object(r.a)("inlineCode",{parentName:"p"},"None")," and ",Object(r.a)("inlineCode",{parentName:"p"},"Some")," available. This means the following getters & methods are available on an ",Object(r.a)("inlineCode",{parentName:"p"},"Option")," -"),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},".isNone")," - is ",Object(r.a)("inlineCode",{parentName:"li"},"true")," if no underlying values is wrapped, effectively the same as ",Object(r.a)("inlineCode",{parentName:"li"},".isEmpty")),Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},".isSome")," - this is ",Object(r.a)("inlineCode",{parentName:"li"},"true")," is a value is wrapped, i.e. if a ",Object(r.a)("inlineCode",{parentName:"li"},"Option<u32>")," has an actual underlying ",Object(r.a)("inlineCode",{parentName:"li"},"u32")),Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},".unwrap()")," - when ",Object(r.a)("inlineCode",{parentName:"li"},"isSome"),", this will return the wrapped value, i.e. for ",Object(r.a)("inlineCode",{parentName:"li"},"Option<u32>"),", this would return the ",Object(r.a)("inlineCode",{parentName:"li"},"u32"),". When the value is ",Object(r.a)("inlineCode",{parentName:"li"},"isNone"),", this call will throw an exception."),Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},".unwrapOr(<default value>)")," - this extends ",Object(r.a)("inlineCode",{parentName:"li"},"unwrap()"),", returning the wrapped value when ",Object(r.a)("inlineCode",{parentName:"li"},"isSome")," and in the case of ",Object(r.a)("inlineCode",{parentName:"li"},"isNone")," it will return the ",Object(r.a)("inlineCode",{parentName:"li"},"<default value>")," passed."),Object(r.a)("li",{parentName:"ul"},Object(r.a)("inlineCode",{parentName:"li"},".unwrapOrDefault()")," - returns either the rapped value when ",Object(r.a)("inlineCode",{parentName:"li"},"isSome"),", or the default for the type when ",Object(r.a)("inlineCode",{parentName:"li"},"isNone"))),Object(r.a)("h2",{id:"working-with-tuples"},"Working with Tuples"),Object(r.a)("p",null,"A tuple is defined in the form of ",Object(r.a)("inlineCode",{parentName:"p"},"(u32, AccountId)"),". To access the individual values, you can access t via the index, i.e."),Object(r.a)("pre",null,Object(r.a)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"// Assuming a tuple defined as `(32, AccountId)`\nconst [count, accountId] = tuple;\n\nconsole.log(`${accountId} has ${count.toNumber()} values`);\n")),Object(r.a)("p",null,"When making a call that expect a ",Object(r.a)("inlineCode",{parentName:"p"},"Tuple")," input, pass it as an array, so to pass the example above into a call, it would be ",Object(r.a)("inlineCode",{parentName:"p"},".call([123, '5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY'])")),Object(r.a)("h2",{id:"boolean-values"},"Boolean values"),Object(r.a)("p",null,"All ",Object(r.a)("inlineCode",{parentName:"p"},"bool")," values are returned as nomal JS ",Object(r.a)("inlineCode",{parentName:"p"},"Booolean")," objects, i.e. they extend the ",Object(r.a)("a",Object(n.a)({parentName:"p"},{href:"https://www.w3schools.com/jsref/jsref_obj_boolean.asp"}),"JS Boolean")," to allow it to be used as a ",Object(r.a)("inlineCode",{parentName:"p"},"Codec")," type. "),Object(r.a)("p",null,"In addition to the default ",Object(r.a)("inlineCode",{parentName:"p"},"getValue()")," on the JS Boolean and the default interfaces explained above, two additional getters have been added for ease-of-use. These are ",Object(r.a)("inlineCode",{parentName:"p"},"isTrue")," and ",Object(r.a)("inlineCode",{parentName:"p"},"isFalse")," that will just return a normal JS primitive ",Object(r.a)("inlineCode",{parentName:"p"},"boolean")," for a quick check without using ",Object(r.a)("inlineCode",{parentName:"p"},"getValue()"),"."),Object(r.a)("h2",{id:"extending-types"},"Extending types"),Object(r.a)("p",null,"For customized chains, the need exists to register types so the API is aware of how to decode values for those types. The next section will provide a ",Object(r.a)("a",Object(n.a)({parentName:"p"},{href:"/docs/api/start/types.extend"}),"walk-through for the definition of custom types")," allowing the definition or re-definition of any type the API is aware of."))}c.isMDXComponent=!0},163:function(e,a,t){"use strict";t.d(a,"a",(function(){return m}));var n=t(0),i=t.n(n);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function l(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function o(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?l(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function s(e,a){if(null==e)return{};var t,n,i=function(e,a){if(null==e)return{};var t,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)t=r[n],a.indexOf(t)>=0||(i[t]=e[t]);return i}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)t=r[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var p=i.a.createContext({}),c=function(e){var a=i.a.useContext(p),t=a;return e&&(t="function"==typeof e?e(a):o(o({},a),e)),t},d={inlineCode:"code",wrapper:function(e){var a=e.children;return i.a.createElement(i.a.Fragment,{},a)}},u=i.a.forwardRef((function(e,a){var t=e.components,n=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(t),m=n,b=u["".concat(l,".").concat(m)]||u[m]||d[m]||r;return t?i.a.createElement(b,o(o({ref:a},p),{},{components:t})):i.a.createElement(b,o({ref:a},p))}));function m(e,a){var t=arguments,n=a&&a.mdxType;if("string"==typeof e||n){var r=t.length,l=new Array(r);l[0]=u;var o={};for(var s in a)hasOwnProperty.call(a,s)&&(o[s]=a[s]);o.originalType=e,o.mdxType="string"==typeof e?e:n,l[1]=o;for(var p=2;p<r;p++)l[p]=t[p];return i.a.createElement.apply(null,l)}return i.a.createElement.apply(null,t)}u.displayName="MDXCreateElement"}}]);