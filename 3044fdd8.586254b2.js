(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{163:function(e,t,n){"use strict";n.d(t,"a",(function(){return f}));var a=n(0),r=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=r.a.createContext({}),p=function(e){var t=r.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},u=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),u=p(n),f=a,m=u["".concat(i,".").concat(f)]||u[f]||d[f]||o;return n?r.a.createElement(m,c(c({ref:t},l),{},{components:n})):r.a.createElement(m,c({ref:t},l))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=u;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:a,i[1]=c;for(var l=2;l<o;l++)i[l]=n[l];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},73:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return c})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return p}));var a=n(2),r=n(6),o=(n(0),n(163)),i={title:"FAQ"},c={unversionedId:"api-contract/FAQ",id:"api-contract/FAQ",isDocsHomePage:!1,title:"FAQ",description:"The list will be updated/expanded as questions come up, dealing with some common issues that API users find.",source:"@site/docs/api-contract/FAQ.md",slug:"/api-contract/FAQ",permalink:"/docs/api-contract/FAQ",editUrl:"https://github.com/polkadot-js/docs/edit/master/docs/api-contract/FAQ.md",version:"current",sidebar:"reference",previous:{title:"Contract",permalink:"/docs/api-contract/start/contract"},next:{title:"Overview",permalink:"/docs/ui-identicon"}},s=[{value:"My ABI cannot be parsed",id:"my-abi-cannot-be-parsed",children:[]},{value:"Why is there a snake_case vs camelCase difference",id:"why-is-there-a-snake_case-vs-camelcase-difference",children:[]}],l={rightToc:s};function p(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(o.a)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(o.a)("p",null,"The list will be updated/expanded as questions come up, dealing with some common issues that API users find."),Object(o.a)("h2",{id:"my-abi-cannot-be-parsed"},"My ABI cannot be parsed"),Object(o.a)("p",null,'When passing an older pre ink! 3.0-rc1 version of the ABI, you will have an "Invalid JSON ABI structure supplied, expected a recent metadata version" error being returned. As explained in the ',Object(o.a)("a",Object(a.a)({parentName:"p"},{href:"/docs/api-contract/start/install"}),"getting started guide")," as of ",Object(o.a)("inlineCode",{parentName:"p"},"@polkadot/api-contract")," 2.2 (and later) the older ink! 2.1 versions are not supported."),Object(o.a)("p",null,"If you are using an older version you would need to use an older version of the API or upgrade your contracts to ink! 3.0."),Object(o.a)("h2",{id:"why-is-there-a-snake_case-vs-camelcase-difference"},"Why is there a snake_case vs camelCase difference"),Object(o.a)("p",null,"The API always tries to use ",Object(o.a)("inlineCode",{parentName:"p"},"camelCase")," where available. This aligns with the de-facto standards that are generally (not always!) used in JS interfaces. This means that when decorating the ABIs into ",Object(o.a)("inlineCode",{parentName:"p"},"contract.<query|tx>.methodName")," the ",Object(o.a)("inlineCode",{parentName:"p"},"methodName")," part would be in camelCase format."),Object(o.a)("p",null,"An example of this would be in the erc20 ink! ABI - the method in the above would be ",Object(o.a)("inlineCode",{parentName:"p"},"balance_of")," however the API (for consistency with the full quite of libraries), decorate this as ",Object(o.a)("inlineCode",{parentName:"p"},"contract.query.balanceOf"),". When calling the ",Object(o.a)("inlineCode",{parentName:"p"},".read")," or ",Object(o.a)("inlineCode",{parentName:"p"},".exec")," directly on the contract, you should still specify the original ABI identifier, e.g. ",Object(o.a)("inlineCode",{parentName:"p"},"contract.read('balance_of', ...)")," (In the next release this will also allow for camelCase lookups in addition to the original Rust/Solidity naming)"))}p.isMDXComponent=!0}}]);