(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{105:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"metadata",(function(){return i})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return u}));var a=n(2),r=n(6),o=(n(0),n(176)),c={title:"Contract"},i={unversionedId:"api-contract/start/contract",id:"api-contract/start/contract",isDocsHomePage:!1,title:"Contract",description:"The ContractPromise interface allows you to interact with a deployed contract. In the previous Blueprint example this instance was created via createContract. In general use, you can also create an instance via new, i.e. when you are attaching to an existing contract on-chain -",source:"@site/docs/api-contract/start/contract.md",slug:"/api-contract/start/contract",permalink:"/docs/api-contract/start/contract",editUrl:"https://github.com/polkadot-js/docs/edit/master/docs/api-contract/start/contract.md",version:"current",sidebar:"reference",previous:{title:"Blueprint",permalink:"/docs/api-contract/start/blueprint"},next:{title:"FAQ",permalink:"/docs/api-contract/FAQ"}},s=[{value:"Reading contract values",id:"reading-contract-values",children:[]},{value:"Sending a transaction",id:"sending-a-transaction",children:[]},{value:"That is it... for now",id:"that-is-it-for-now",children:[]}],l={rightToc:s};function u(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"ContractPromise")," interface allows you to interact with a deployed contract. In the previous ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/api-contract/start/blueprint"}),"Blueprint example")," this instance was created via ",Object(o.b)("inlineCode",{parentName:"p"},"createContract"),". In general use, you can also create an instance via ",Object(o.b)("inlineCode",{parentName:"p"},"new"),", i.e. when you are attaching to an existing contract on-chain -"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"import { ContractPromise } from '@polkadot/api-contract';\n\n// Attach to an existing contract with a known ABI and address\nconst contract = new ContractPromise(api, abi, address);\n\n// Read from the contract\n...\n")),Object(o.b)("p",null,"Either via a create above or via a call to ",Object(o.b)("inlineCode",{parentName:"p"},"createContract")," both instances are the same. The ",Object(o.b)("inlineCode",{parentName:"p"},"Contract")," provides a wrapper around the ",Object(o.b)("inlineCode",{parentName:"p"},"Abi")," and allows you to call either ",Object(o.b)("inlineCode",{parentName:"p"},"read")," or ",Object(o.b)("inlineCode",{parentName:"p"},"exec")," on a contract to interact with it."),Object(o.b)("h2",{id:"reading-contract-values"},"Reading contract values"),Object(o.b)("p",null,"In the ",Object(o.b)("inlineCode",{parentName:"p"},"Blueprint")," example we have instantiated an incrementer contract. In the following examples we will continue using it to read from and execute transactions into, since it is a well-known entity. To read a value from the contract, we can do the following -"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"// Read from the contract via an RPC call\nconst value = 0; // only useful on isPayable messages\nconst gasLimit = 1000000n;\n\n// Perform the actual read (no params at the end, for the get message)\n// (We perform the send from an account address, it doesn't get executed)\nconst value = await contract\n  .read('get', value, gasLimit)\n  .send(alicePair.address);\n\n// The actual result from RPC as `ContractExecResult`\nconsole.log(value.result.toHuman());\n\n// check if the call was successful\nif (value.result.isSuccess) {\n  // should output 123 as per our initial set (output here is an i32)\n  console.log(value.output.toHuman());\n\n  // the amount of gas consumed (u64 value)\n  console.log(value.result.asSuccess.gasConsumed.toHuman());\n} else {\n  console.error('Call failed');\n}\n")),Object(o.b)("p",null,"Underlying the above ",Object(o.b)("inlineCode",{parentName:"p"},".read")," using the ",Object(o.b)("inlineCode",{parentName:"p"},".call")," RPC on the contracts palette to retrieve the value. When executing it encodes the message using the selector and the input values to allow execution in the contract environment. This can be executed on any contract message, unlike the execution below it will only read state, not actually execute."),Object(o.b)("h2",{id:"sending-a-transaction"},"Sending a transaction"),Object(o.b)("p",null,"In addition to using the ",Object(o.b)("inlineCode",{parentName:"p"},".read")," on a contract, the ",Object(o.b)("inlineCode",{parentName:"p"},".exec")," method is provides to send an actual encoded transaction to the contract. Expanding on our above example, we can now execute and then retrieve the subsequent value -"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"// We will use these values for the execution\nconst value = 0; // only useful on isPayable messages\nconst gasLimit = 1000000n;\nconst incValue = 1;\n\n// Send the transaction, like elsewhere this is a normal submittable\n// extrinsic with the same rules as applied in the API\nawait contract\n  .exec('inc', value, gasLimit, incValue)\n  .signAndSend(alicePair, (result) => {\n    if (result.status.isInBlock) {\n      console.log('in a block');\n    } else if (result.status.isFinalized) {\n      console.log('finalized');\n    }\n  });\n")),Object(o.b)("p",null,"If we perform the same ",Object(o.b)("inlineCode",{parentName:"p"},".get")," read on the value now, it would be ",Object(o.b)("inlineCode",{parentName:"p"},"124"),"."),Object(o.b)("h2",{id:"that-is-it-for-now"},"That is it... for now"),Object(o.b)("p",null,"This was a whirl-wind tour of what the API provides in terms of the ",Object(o.b)("inlineCode",{parentName:"p"},"@polkadot/api-contract")," interface. It is not perfect yet, we would like to expand it to allow for greater type-checking on the contracts (instead of read/exec wit messages), but hopefully in the current state it already enhances the way you can interact with contracts."))}u.isMDXComponent=!0},176:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return m}));var a=n(0),r=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=r.a.createContext({}),u=function(e){var t=r.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=u(e.components);return r.a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},b=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),p=u(n),b=a,m=p["".concat(c,".").concat(b)]||p[b]||d[b]||o;return n?r.a.createElement(m,i(i({ref:t},l),{},{components:n})):r.a.createElement(m,i({ref:t},l))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,c=new Array(o);c[0]=b;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:a,c[1]=i;for(var l=2;l<o;l++)c[l]=n[l];return r.a.createElement.apply(null,c)}return r.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);